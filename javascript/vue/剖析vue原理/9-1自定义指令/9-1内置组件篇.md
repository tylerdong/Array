## 1.前言
`<keep-alive>`是`Vue`实现的的一个内置组件，也就是说`Vue`不仅实现了一套组件化的机制，也实现了一些内置组件，关于`<keep-alive>`组件，官网如下介绍：

>`<keep-alive>`是`Vue`中内置的一个抽奖组件，它自身不会渲染一个`DOM`元素，也不会出现在父组件链中。当用它来包裹动态组件时，会缓存不活动的组件实例，而不是销毁他们。

这句话的意思简单来说：就是我们可以把一些不常变动的组件或者需要缓存的组件用`<keep-alive>`包裹起来，这样`<keep-alive>`就会帮我们把组件保存在内存中，而不是直接的销毁，这样做可以保留组件的状态活避免多次重新渲染，以提高页面性能。  
我们来举个例子看看，假如有如下的代码：  
```html
<div id="app">
  <button @click="switchComp('child1')">组件1</button>
  <button @click="switchComp('child2')">组件2</button>
  <component :is="chooseComponse"></component>
</div>
<script>
  var child1 = {
    template: `<div>组件1：<input type="text"/></div>`
  }
  var child2 = {
    template: `<div>组件2：<input type="text"/></div>`
  }
  var vm = new Vue({
    el: '#app',
    components: {child1, child2},
    data() {
      return chooseComponent: 'child1'
    },
    methods: {
      switchComp(component) {
        this.chooseComponent = component
      }
    }
  })
</script>
```

可以看到，上述代码中定义了两个子组件`child1`和`child2`，然后使用两个按钮和一个动态组件来做出点击按钮切换不同组件的效果。但是我们给组件1和组件2的输入框中分别输入了不同的内容之后，点击按钮切换组件的时候，之前输入的内容已经不存在了，这说明点击按钮切换组件是把之前的组件销毁了，然后又重新挂载了一次。  

但是我们有时候又有这样的需求：当用户切回组件的时候保留之前的组件状态。此时`Vue`内置的`<keep-alive>`组件就派上用场了，我们将上述代码用`<keep-alive>`包裹一下，如下：  
```html
<div id="app">
  <button @click="switchComp('child1')">组件1</button>
  <button @click="switchComp('child2')">组件2</button>
  <keep-alive>
    <component :is="chooseComponent"></component>
  </keep-alive>
</div>
```html

这样，`child1`和`child2`不管怎么切换，它都能保留自己切换前的状态。这就说明，当我们切换组件的时候，组件没有被销毁，而是保存在内存中，这样再次切换回去的时候就可以拿到之前的状态。  
那么，`<keep-alive>`组件是如何实现这个功能的呢？本篇文章就来解析`<keep-alive>`组件的内部实现原理。

## 2.用法回顾
介绍原理之前，我们先根据官方文档来回顾一下`<keep-alive>`组件的具体用法，如下：  
`<keep-alive>`可以接收三个属性：  
- `include` -字符串或者正则表达式，只有名称匹配的组件会被缓存。
- `exclude` -字符串或者正则表达式，任何名称匹配的组件都不会被缓存。
- `max` -数字，最多可以缓存多少组件实例。

`include`和`exclude`属性允许组件有条件的缓存。二者都可以用逗号分隔字符串，正则表达式，或者一个数组来表示：  
```html
<!--使用分隔字符串-->
<keep-alive include="a,b">
  <component :is="view"></component>
</keep-alive>

<!--使用v-bind，正则表达式-->
<keep-alive :include="/a|b/">
  <component :is="view">
</keep-alive>

<!--使用v-bind，数组-->
<keep-alive :include="['a', 'b']">
  <component :is="view">
</keep-alive>
```

匹配时首选检查组件自身的`name`选项，如果`name`选项不可用，则匹配他的局部注册名称（父组件`components`选项的键值）。匿名组件不能被匹配。  

`max`表示最多可以缓存多少组件实例。一旦这个数字达到了，在新实例被创建之前，**已缓存组件中最久没有被访问的实例**会被销毁。  

请注意max选项，后面会详细说明。
```html
<keep-alive>
  <component :is="view"></component>
</keep-alive>
```
## 3.实现原理
`<keep-alive></keep-alive>`组件的定义位于源码`src/core/components/keep-alives.js`文件中，如下：

```javascript
export default {
  name: 'keep-alive',
  abstract: true,

  props: {
    include: [String, RegExp, Array],
    exclude: [String, RegExp, Array],
    max: [String, Number]
  },

  created() {
    this.cache = Object.create(null)
    this.keys = []
  },

  destroyed() {
    for(const key in this.cache) {
      pruneCacheEntry(this.cache, key, this.keys)
    }
  },

  mounted() {
    this.$watch('include', val => {
      pruneCache(this, name => matches(val, name))
    })
    this.$watch('exclude', val => {
      pruneCache(this, name => !matches(val, name))
    })
  },

  render() {
    /*获取默认插槽中的第一个组件节点*/
    const slot = this.$slots.default
    const vnode = getFirstComponentChild(slot)
    /*获取该组件节点的componentOptions*/
    const componentOptions = vnode && vnode.componentOptions

    if (componentOptions) {
      /*获取该组件节点的名称，优先获取组件的name字段，如果name不存在则获取组件的tag*/
      const name = getComponentName(componentOptions)

      const {include, exclude} = this
      /*如果name不再include中或者存在于exclude中则表示不缓存，直接返回vnode*/
      if ((include && (!name || !matches(include, name))) || (exclude && name && matches(exclude, name))) {
        return vnode
      }
      const {cache, keys} = this
      const key = vnode.key == null
        ? componentsOptions.Ctor.cid + (componentOptions.tag ? `::${componentOptions.tag}` '')
        : vnode.key
      if (cache[key]) {
        vnode.componentInstance = cache[key].componentInstance
        remove(keys, key)
        keys.push(key)
      } else {
        cache[key] = vnode
        keys.push(key)
        if (this.max && keys.length > parseInt(this.max)) {
          pruneCacheEntry(cache, keys[0], keys, this._vnode)
        }
      }
      vnode.data.keepAlive = true
    }
    return vnode || (slot && slot[0])
  }
}
```
可以看到，该组件内没有常规的`<template></template>`标签，取而代之的是它内部多了一个叫做render的函数，所以它不是一个常规的模板组件，而是一个函数式组件。执行`<keep-alive></keep-alive>`组件渲染的时候，就会执行到`render`函数。  

### props
在`props`选项内接收传进来的三个属性：include，exclude和max。如下：  
```javascript
props: {
  include: [String, RegExp, Array],
  exclude: [String, RegExp, Array],
  max: [String, Number]
}
```
`include`表示只有匹配到的组件会被缓存，而`exclude`表示任何匹配到的组件都不会被缓存，`max`表示缓存组件的数量，应为我们是缓存的`vnode`对象，它也会持有DOM，当我们缓存的组件很多的时候，会占用内存，所以该配置允许我们指定缓存组件的数量。

### created
在created钩子函数里定义并初始化了两个属性：`this.cache`和`this.keys`。
```javascript
created() {
  this.cache = object.create(null)
  this.keys = []
}
```
`this.cache`是一个对象，用来存储需要缓存的组件，它将以如下形式存储：
```javascript
this.cache = {
  'keys': '组件1',
  'keys': '组件2'
}
```
`this.keys`是一个数组，用来存储每个需要缓存的组件的`key`，即对应`this.cache`对象中的键值。

### destroyed
当`<keep-alive>`组件被撤销时，会调用`destroyed`钩子函数，在该钩子函数里会遍历`this.cache`对象，然后将那些被缓存的并且当前没有出狱被渲染状态的组件销毁并将其从`this.cache`对象中剔除。如下：
```javascript
destroyed() {
  for (const key in this.cache) {
    pruneCacheEntry(this.cache, key, this.keys)
  }
}
function pruneCacheEntry(cache, key, keys, current) {
  const cached = cache[key]
  /*判断当前没有处于被渲染状态的组件，将其销毁*/
  if (cached && (!current || cached.tag !== current.tag)) {
    cached.componentInstance.$destroy()
  }
  cache[key] = null
  remove(keys, key)
}
```

### mounted
在`mounted`钩子函数中观察`include`和`exclude`的变化，如下：
```javascript
mounted() {
  this.$watch('include', val => {
    pruneCache(this, name => matches(val, name))
  })
  this.$watch('exclude', val => {
    pruneCache(this, name => !matches(val, name))
  })
}
```
如果include或exclude发生变化，即表示定义需要缓存的组件的规则或者不需要缓存的组件的规则发生了变化，那么就执行pruneCache函数，函数如下：

```javascript
function pruneCache(keepAliveInstance, filter) {
  const {cache, keys, _vnode} = keepAliveInstance
  for (const key in cache) {
    const cacheNode = cache[key]
    if (cachedNode) {
      const name = getComponentName(cacheNode.componentOptions)
      if (name && !filter(name)) {
        pruneCacheEntry(cache, key, keys, _vnode)
      }
    }
  }
}

function pruneCacheEntry(cache, key, keys, current) {
  const cached = cache[key]
  if (cached && (!current || cached.tag !== current.tag)) {
    cached.componentInstantce.$destroy()
  }
  cache[key] = null
  remove(keys, key)
}
```

在该函数内对`this.cache`对象进行遍历，取出每一项的`name`值，用其与新的缓存葛泽进行匹配，如果匹配不上，则表示新的缓存规则下该组件已经不需要被缓存，则调用`pruneCacheEntry`函数对这个已经不需要缓存的组件实例先销毁掉，然后再将其从`this.cache`对象中剔除。

### render
接下来就是重头戏render函数，以上工作都是一些辅助工作，真正实现缓存功能的就在这个render函数里，接下来我们逐行分析。  

在render函数中首先获取第一个子组件节点的vnode
```javascript
/*获取默认插槽中的第一个组件节点*/
const slot = this.$slots.default
const vnode = getFirstComponentChild(slot)
```
由于我们也是在<keep-alive>标签内部写DOM，所以可以先获取到它的默认插槽，然后再获取到它的第一个子节点。<keep-alive>只处理第一个子元素，所以一般和它搭配使用的有component动态组件或者router-view。

接下来获取该组件节点的名称：
```javascript
/*获取该组件节点的名称*/
const name = getCmponentName(componentOptions)

/*优先获取组件的name字段，如果name不存在则获取组件的tag*/
function getComponentName(opts: ?VNodeComponentOptions): ?string {
  return opts && (opts.Ctor.options.name || opts.tag)
}
```
然后用组件名称跟include，exclude中的匹配规则去匹配：
```javascript
const {include, exclude} = this
/*如果name与include规则不匹配或者与exclude规则匹配则表示不缓存，直接返回vnode*/
if ((include && (!name || !matches(include, name))) || (exclude && name && matches(exclude, name))) {
  return vnode
}
```
如果组件名称与include规则不匹配或者与exclude规则匹配，则表示不缓存该组件，直接返回这个组件的vnode，否则的话走下一步缓存：
```javascript
const {cache, keys} = this
/*获取组件的key*/
const key = vnode.key == null ? componentOptions.Ctor.cid + (componentOptions.tag ? `::${componentOptions.tag}` : '') : vnode.key

/*如果命中缓存，则直接从缓存中拿vnode的组件实例*/
if (cache[key]) {
  vnode.componentInstance = cache[key].componentInstance
  /*调整该组件key的顺序，将其从原来的地方删掉并重新放在最后一个*/
  remove(keys, key)
  keys.push(key)
}
/*如果没有命中缓存，则将其设置进缓存*/
else {
  cache[key] = vnode
  keys.push(key)
  /*如果配置了max并且缓存的长度超过了this.max，则从缓存中删除第一个*/
  if (this.max && keys.length > parseInt(this.max)) {
    pruneCacheEntry(cache, keys[0], keys, this._vnode)
  }
}
/*最后设置keepAlive标记位*/
vnode.data.keepAlive = true
```

首先获取组件的key值

```javascript
const key = vnode.key == null ? componentOptions.Ctor.cid + (componentOptions.tag ? `::${componentOptions.tag}` : '') : vnode.key
```
拿到key值后去this.cache对象中去寻找是否有该值，如果有则表示该组件有缓存，即命中缓存。

```javascript
/*如果命中缓存，则直接从缓存中拿vnode的组件实例*/
if (cache[key]) {
  vnode.componentInstance = cache[key].componentInstance
  /*调整该组件key的顺序，将其从原来的地方删掉并重新放在最后一个*/
  remove(keys, key)
  keys.push(key)
}
```
直接从缓存中拿vnode的组件实例，此时重新调整该组件key的顺序，将其从原来的地方删除并重新放在this.keys中最后一个。  

如果this.cache对象中没有该key值：
```javascript
/*如果没有命中缓存，则将其设置进缓存*/
else {
  cache[key] = vnode
  keys.push(key)
  /*如果配置了max并且缓存的长度超过了this.max，则从缓存中删除第一个*/
  if (this.max && keys.length > parseInt(this.max)) {
    pruneCacheEntry(cache, keys[0], this._vnode)
  }
}
```
表明该组件还没有被缓存过，则以该组件的key为键，组件vnode为值，将其存入this.cache对象中，并且把key存入this.keys中。此时再判断this.keys中缓存组件的数量是否超过了设置的最大缓存数量值，this.max，如果超过了，则把第一个缓存组件删掉。  

那么问题来了，<font color="red">**为什么要删除第一个缓存组件？ 为什么命中缓存了还要调整组件key的顺序？**</font>

这里应用了一个缓存淘汰策略LRU：

>LRU(**Least recently used**，最近最少使用)算法根据数据的历史访问纪录来淘汰数据，其核心思想是“如果数据最近被访问过，那么将来被访问的几率也更高”。

它的算法是这样的：
1.将新数据从尾部插入到`this.keys`中；
2.每当缓存命中（即缓存数据被访问），则将数据移到`this.keys`的尾部；
3.当`this.keys`满的时候，将头部的数据丢弃；

LRU的核心思想是如果数据最近被访问过，那么将来被访问的几率也很高，所以我们将命中缓存的组件key重新插入到`this.keys`的尾部，这样`this.keys`中越往头部的数据将来被访问几率越低，所以当缓存数量达到最大值的时候，我们就删除头部访问率最底的数据，即`this.keys`中第一个缓存的组件。就是上面提到的**已缓存组件中最久没被访问的实例会被销毁**的原因所在。  

以上工作昨晚后设置vnode.data.keepAlive = true，最后将vnode返回。这就是render函数的整个过程。

## 4.生命周期钩子
组件一旦被<keep-alive>缓存，那么再次渲染的时候就不会执行created，mounted等钩子函数了，但是我们很多业务场景都希望被缓存的组件被再次渲染的时候做一些事情，好在vue提供了activated和deactivated两个钩子函数，它执行的时机是<keep-alive>包裹的组件激活时和停用时调用，下面我们通过一个简单的例子来演示一下这两个钩子函数，如下：
```javascript
  let A = {
    template: '<div class="a"><p>A Comp</p></div>',
    name: 'A',
    mounted() {
      console.log('Comp A mounted')
    },
    activated() {
      console.log('Comp A activeted')
    },
    deactivated() {
      console.log('Comp A deactivated')
    }
  }
  let B = {
    template: '<div class="a"><p>B Comp</p></div>',
    name: 'B',
    mounted() {
      console.log('Comp B mounted')
    },
    activated() {
      console.log('Comp B activeted')
    },
    deactivated() {
      console.log('Comp B deactivated')
    },
  }
  let vm = new Vue({
    el: '#app',
    template: '<div>' +
      '<keep-alive>' +
      '<component :is="currentComp"></component>' +
      '</keep-alive>' +
      '<button @click="change">switch</button>' +
      '</div>',
      data() {
        return {
          currentComp: 'A'
        }
      },
      methods: {
        change() {
          this.currentComp = this.currentComp == 'A' ? 'B' : 'A'
        }
      },
      components: {A, B}
  })
```
当第一次打开页面时，组件A被挂载，执行了组件A的mounted和activated钩子函数，当点击switch之后，组件A停止调用，同时组件B被挂载，此时执行A组件的deactivated和组件B的mounted和activated钩子函数。此后，再次点击switch按钮，组件B停止调用，组件A被激活，只执行了组件B的deactivated钩子和组件A的activated钩子，注意有先收顺序，先deactivated，后activated，不执行created和mounted等。






