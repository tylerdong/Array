# 1.前言

在上篇文章中我们了解到当HTML解析器解析到文本内容的时候会调用4个钩子函数，其中chars函数用来创建文本类型的AST节点，并且chars函数中会根据文本内容是否包含变量来创建含有变量的AST节点和不含变量的AST节点，如下：

```javascript
//当解析到标签的文本是，触发chars函数
chars(text) {
  if (res = parseText(text)) {
    let element = {
      type: 2,
      expression: res.expression,
      tokens: res.tokens,
      text
    }
  } else {
    let element = {
      type: 3,
      text
    }
  }
}
```

从上面的代码中可以看到，创建包含变量的AST节点的时候节点的type属性为2，并且多出两个属性：`expression`和`tokens`。本文介绍文本解析器如何解析文本，如何处理`expression`和`tokens`的。

# 2.结果分析

研究文本解析器内部原理之前，先看一下由`HTML`解析器解析得到的文本内容进过文本解析器后输出的结果是什么样子的，这对后面分析文本解析器内部原理有帮助。

从上面的`chars`函数代码可以看到，把`HTML`解析器解析得到的文本内容`text`传给文本解析器`parseText`函数，根据`parseText`函数是否有返回值判断是否包含变量，以及返回值中取到需要的`expression`和`tokens`。我们先看一下啊`parseText`函数如果有返回值，那么它的返回值是什么样子的。

假设现有HTML解析器解析得到的文本内容如下：

```javascript
let text = "我叫{{name}}，我今年{{age}}岁了"
```

经过文本解析器解析后得到：

```javascript
let res = parseText(text)
res = {
  expression: "我叫" + _s(name) + ", 我今年" + _s(age) + "岁了",
  tokens: [
    "我叫",
    {'@binding', name},
    ",我今年",
    {'@binding': age},
    "岁了"
  ]
}
```

从上面的结果中可以看到，`expression`属性就是把文本中的变量和非变量提取出来，然后把变量用`_S()`包裹，最后按照文本中的顺序把他们用+连接起来。而tokens是个数组，数组内容也是文本中的变量和非变量，不一样的是把变量构造成了一个对象`{'@binding', xxx}`。

那么这么做有什么用呢？主要是为了给后面代码生成代码阶段时的`render`函数使用，后面详细说明，此处可暂时理解为在构造形式。总结一下，文本解析器内部就干了三件事：

- 判断传入的文本是否包含变量
- 构造`expression`
- 构造`tokens`

# 3.源码分析
文本解析器的源码位于src/compiler/parser/text-parser.js中，代码如下：
```javascript
const defaultTagRE = /\{\{((?:.|\n)+?)\}\}/g
const buildRegex = cached(delimiters => {
  const open = delimiters[0].replace(regexEscapeRE, '\\$&')
  const open = delimiters[1].replace(regexEscapeRE, '\\$&')
  return new RegExp(open + '((?:.|\\n)+?)' + close, 'g')
})

export function parseText(text, delimiters) {
  const tagRE = delimiters ? buildRegex(delimiters) : defaultTagRE
  if (!tagRE.test(text)) {
    return
  }
  const tokens = []
  const rawTokens = []
  let lastIndex = regRe.lastIndex = 0
  /**
   * let lastIndex = tagRE.lastIndex = 0
   * 上面的代码等同于：
   * tagRE.lastIndex = 0
   * let lastIndex = tagRE.lastIndex
   */
  while((match = tagRE.exec(text))) {
    index = match.index
    //push text token
    if (index > lastIndex) {
      //先把花括号前面的文本放入tokens中
      rawTokens.push(tokenValue = text.slice(lastIndex, index))
      tokens.push(JSON.stringify(tokenValue))
    }
    //tag token
    //取出花括号中间的变量exp
    const exp = parseFilters(match[1].trim())
    //把变量exp改成_s(exp)的形式也放入tokens中
    tokens.push(`_s(${exp})`)
    rawTokens.push({'@binding': exp})
    //设置lastIndex以保证下一轮循环时，只从’}}‘后面再开始匹配正则
    lastIndex = index + match[0].length
  }
  //当剩下的text不再被正则匹配上时，表示所有变量已经处理完毕
  //此时如果lastIndex < text.length，表示在最后一个变量后面还有文本
  //最后将后面的文本再加入到tokens中
  if (lastIndex < text.length) {
    rawTokens.push(tokenValue = text.slice(lastIndex))
    tokens.push(JSON.stringify(tokenValue))
  }

  //最后把数组tokens中所有元素用+拼接起来
  return {
    expression: tokens.join('+'),
    tokens: rawTokens
  }
}
```

parseText函数接收两个参数，一个是传入的待解析的文本内容text，一个包裹变量的符号delimiters。

```javascript
const tegRE = delimiters ? buildRegex(delimiters) : defaultTagRE
```

函数体内定义变量tagRE，表示一个正则表达式。这个是用来检验文本中是否包含变量。tagRE是用来检测文本中是否包含双花括号。tagRE又是可变的，它根据是否传入了deliters参数返回返回不同的正则表达式，也就是如果没有传入delimiters参数，则是检验文本是否包含花括号，否则会检测文本是否包含传入的值。换句话说在Vue项目中，用户可以自定义文本内容包含变量所使用的符号，例如可以使用%。

接下来用tagRE去匹配传入的文本内容，判断是否包含变量，若不包含，则直接返回，如下

```javascript
if (!tagRE.test(text)) {
  return
}
```

如果包含变量，就继续往下运行

```javascript
const tokens = []
const rawTokens = []
let lastIndex = tagRE.lastIndex = 0
let match, index, tokenValue
while((match = tagRE.exec(text))) {

}
```

接下来会开启一个while循环，循环结束条件是text.exec(text)的结果match是否为null，exec()方法是在一个字符串中执行匹配检索，如果它没有找到任何匹配就返回null，但如果它找到了一个匹配就返回一个数组。例如：

```javascript
tagRE.exec('hello {{name}}, I am {{age}}')
//返回["{{name}}", "name", index: 6, input: "hello {{name}}，I am {{age}}", groups: undefined]
tagRE.exec('hello')
//返回null
```

可以看到，当匹配上时，匹配结果的第一个元素是字符串中第一个完整的带有包裹的变量，第二个元素是第一个被包裹的变量名，第三个元素是第一个变量在字符串中的其实位置。

```javascript
while((match = tagRE.exec(text))) {
  index = match.index
  if (index > lastIndex) {
    //先把花括号前面的文本放入tokens中
    rawTokens.push(tokenValue = text.slice(lastIndex, index))
    tokens.push(JSON.stringify(tokenValue))
  }
  //tag token
  //取出花括号中间的变量exp
  const exp = match[1].trim()
  //把变量exp改成_s(exp)形式也放入tokens中
  tokens.push(`_s(${exp})`)
  rawTokens.push({'@binding': exp})
  //设置lastIndex以保证下一轮循环的时候从花括号后面开始匹配正则
  lastIndex = index + match[0].length
}
```

上面代码中，首选取得字符串中第一个变量在字符串中的其实位置赋值给index，然后比较`index`和`lastIndex`的大小，`lastIndex`是什么呢？在上面定义的变量中个，定义了`let lastIndex = tagRE.lastIndex = 0`，`lastIndex`就是`ragRE.lastIndex`。调用`exec()`的表达式对象有修饰符`g`的时候，它将把当前正则表达式对象的`lastIndex`属性设置为设置为紧挨着匹配子串的字符位置，当同一个正则表达式第二次调用`exec()`，它将会从`lastIndex`属性所指示的字符串处开始检索，如果`exec()`没有发现任何匹配结果，它会将`lastIndex`重置为`0`。示例如下：

```javascript
const tagRE = /\{\{((?:.|\n)+?)\}\}/g
tagRE.exec("hello {{name}}, I am {{age}}")
tagRE.lastIndex //14
```

从示例可以看到，`tagRE.lastIndex`就是第一个包裹变量最后一个}所在字符串的位置

lastIndex初始值为0。

那么接下来就好理解了，当i`ndex > lastIndex`时，表示变量前面有纯文本，那么就把这段纯文本截取出来，存入`rawTokens`中，同时再调用`JSON.stringify`给这段文本包裹上双引号，存入`tokens`中，如下：

```javascript
if (index > lastIndex) {
  //先把花括号前面的文本放入tokens中
  rawTokens.push(tokenValue = text.slice(lastIndex, index))
  tokens.push(JSON.stringify(tokenValue))
}
```

如果`index`不大于`lastIndex`，那说明index也为0，即该文本一开始就是变量，例如：`hello`。Name此时变量前面没有纯文本，那就不用截取，直接取出匹配结果的第一个元素变量名，将其用_s()包裹存入`tokens`中，同时再把变量名构造成`{'@binding': exp}`存入`rawTokens`中，如下：

```javascript
//取出花括号中间的变量exp
const exp = match[1].trim()
//把变量exp改成_s(exp)形式放入tokens中
tokens.push(`_s(${exp})`)
rawTokens.push({'@bindging': exp})
```

接着，更新lastIndex以保证下一轮循环时，直接从花括号后面开始匹配正则，如下：

```javascript
lastIndex = index + match[0].length
```

接着，当while循环完毕时，表明文本中所有变量已经被解析完毕，如果此时lastIndex < text.length，那就说明最后一个变量的后面还有纯文本，那就将其再存入`tokens`和`rawTokens`中，如下：

```javascript
//当剩下的text不再被正则表达式匹配上时，表示所有变量已经处理完毕
//如果此时lastIndex < text.length，表示在最后一个变量后面还有文本
//最后将后面的文本再加入到tokens中去
if (lastIndex < text.length) {
  rawTokens.push(tokenValue = text.slice(lastIndex))
  tokens.push(JSON.stringify(tokenValue))
}
```

最后，把`tokens`数组里的元素用+连接，和`rawTokens`一并返回，如下：

``` javascript
return {
  expression: token.join('+'),
  tokens: rawTokens
}
```

# 4.总结

本文介绍了文本解析器的内部工作原理，文本解析器的作用就是将HTML解析器得到的文本内容进行二次解析，解析文本内容中是否包含变量，如果是，则将变量提取出来进行加工，为后续的`render`函数做准备。

