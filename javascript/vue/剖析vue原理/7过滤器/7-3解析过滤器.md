# 1.前言

在上篇文章中我们讲到，无论用户是以什么方式使用过滤器，终归是将解析器写在模板中，既然是在模板中，那它肯定就会被解析编译，通过解析用户缩写的模板，进而解析用户缩写的过滤器`message | filterA | filterB`中那部分是被处理的表达式，那部分是过滤器id及其参数。  

还记得我们在介绍模板编译篇的解析阶段中说过，用户缩写的模板会被三个解析器所解析，分别是HTML解析器，parseHTML，文本解析器parseText和过滤器解析器parseFilter。其中HTML解析器是主线，在使用HTML解析器parseText函数解析模板HTML标签的过程中，如果遇到文本信息，就会调用文本解析器parseText函数进行文本解析；如果遇到文本中包含过滤器，就会调用过滤器解析器parseFilters函数进行解析。在之前的文章中，我们只对HTML解析器parseHTML和文本解析器parseText内部原理进行了分析，还没有分析过滤器解析器parseFilters，那么笨篇文章就来分析过滤器解析器的内部原理。

# 2.在何处解析过滤器
我们一再强调，过滤器又两种使用方式，分别是在双花括号插值中和在v-bind表达式中，如下：
```javascript
<!--在双花括号中-->
{{ message | capitalize }}

<!--在v-bind中-->
<div v-bind:id="rawId | formatId"></div>
```
两种方式不同的使用方式唯一的区别是将过滤器写在不同的地方，既然又两种不同的方式可以写过滤器，那解析的时候必然要在这两种不同的地方都进行解析。

- 写在v-bind表达式中
v-bind表达式中的过滤器它属于存在于标签属性中，那么写在该处的过滤器就需要在处理标签属性时进行接卸。我们知道在HTML解析器parseHTML函数中负责处理标签属性的函数是parseAttrs，所以会在processAttrs函数中调用过滤器解析器parseFilters函数对写在该处的过滤器进行解析，如下：
```javascript
function processAttrs(el) {
  //省略无关代码
  if(bindRE.test(name)) {
    //省略无关代码
    value = parseFilters(value)
  }
}
```

- 写在双花括号中
在双花括号中的过滤器它属于存在于标签文本中，那么写在该处的过滤器就需要在处理标签文本的时候进行解析。我们知道，在HTML解析器parseHTML函数中，当遇到文本信息时会调用parseHTML函数的chars钩子函数，在chars钩子函数内部优惠调用文本解析器parseText函数对文本进行解析，而写在该处的过滤器它就是存在于文本中，所以会在文本解析器parseText函数中调用过滤器解析器parseFilters函数对写在该处的过滤器进行解析，如下：
```javascript
export function parseText(text, delimiters) {
  const exp = parseFilters(match[1].trim())
}
```
我们已经知道了过滤器会在何处解析，那么接下来我们就来分析过滤器解析器parseFilters函数，来看看内部使如何对过滤器进行解析的。

# 3.parseFilters函数分析
parseFilters函数的定义位于源码的src/complier/parser/filter-parser.js文件中，其代码如下：

```javascript
export function parseFilters(exp) {
  let inSingle = false                // exp是否在‘’中
  let inDouble = false                // exp是否在“”中
  let inTemplateString = false        // exp是否在``中
  let inRegex = false                 // exp是否在\\中
  let curly = 0                       // 在exp中发现一个 { 则curly减1，直到culy为0说明{...}闭合
  let square = 0                      // 在exp中发现一个 [ 则kurly减1，直到culy为0说明[...]闭合
  let paren = 0                       // 在exp中发现一个 { 则kurly减1，直到culy为0说明(...)闭合
  let lastFilterIndex = 0
  let c, prev, i, expression, filters

  for(i = 0; i < exp.length; i++) {
    prev = c
    c = exp.charCodeAt(i)
    if (inSingle) {
      if (c === 0x27 && prev !== 0x5C) inSingle = false
    } else if (inDouble) {
      if (c == 0x60 && prev !== 0x5C) inDouble = false
    } else if (inTemplateString) {
      if (c === 0x60&& prev !== 0x5C) inTemplateString == false
    } else if (inRegex) {
      if (c === 0x2f && prev !== 0x5C) inRegex = false
    } else if (
      c === 0x7C &&
      exp.charCodeAt(i + 1) !== 0x7C &&
      exp.charCodeAt(i - 1) !== 0x7C &&
      !curly && !square && !paren
    ) {
      if (expression === undefined) {
        lastFilterIndex = i + 1
        expression = exp.slice(0, i).trim()
      } else {
        pushFilter()
      }
    } else {
      switch(c) {
        case 0x22: inDouble = true; break               //"
        case 0x27: inSingle = true; break               //'
        case 0x60: inTemplateString = true; break       //`
        case 0x28: paren++; break                       //(
        case 0x29: paren--; break                       //)
        case 0x5B: square++; break                      //[
        case 0x5D: square--; break                      //]
        case 0x7B: curly++; break                       //{
        case 0x7D: curly--; break                       //}
      }
      if ( === 0xf) {
        let j = i - 1
        let p
        //find first non-whitespace prev char
        for(; j >= 0; j--) {
          p = exp.charAt(j)
          if (p !== ' ') break
        }
        if (!p || !validDivsionCharRE.test(p)) {
          inRegex = true
        }
      }
    }
  }

  if (expression === undefined) {
    expression = exp.slice(0, i).trim()
  } else if (lastFilterIndex !== 0) {
    pushFilter()
  }

  function pushFilter() {
    (filters || (filters = [])).push(exp.slice(lastFilterIndex, i).trim())
    lastFilterIndex = i + 1
  }

  if (filters) {
    for(i = 0; i < filters.length; i++) {
      expression = wrapFilter(expression, filters[i])
    }
  }
  return expression
}

function wrapFilter(exp: string, filter: string): string{
  const i = filter.indexOf('(')
  if (i < 0) {
    return `_f("${filter}")(${exp})`
  } else {
    const name = filter.slice(0, i)
    const args = filter.slice(i + 1)
    return `_f(${name})(${exp}${args !== ')' ? ',' + args: args})`
  }
}
```

该函数的作用就是将传入的形如'message | capitalize'这样的过滤器字符串转化成_f("capitalize")(essage)，接下来我们就分析一下内部逻辑。  
在这个函数内部，首先定义了一些变量，如下：
```javascript
let inSingle = false
let inDouble = false
let inTemplateString = false
let inRegex = false
let curly = 0
let square = 0
let paren = 0
let lastFilterIndex = 0
```

- inSingle: 标志exp是否在单引号里
- inDouble: 标志exp是否在双引号里
- inTemplateString: 标志exp是否在模板字符串中
- inRegex: 标志exp是否\\中
- curly = 0: 在exp中发现一个左括号{则curly加1，发现一个}则curly减1，直到curly为0则说明闭合
- square = 0: 在exp中发现一个左中括号则curly加1，发现一个右中括号则curly减1，直到curly为0则说明闭合
- paren = 0: 在exp中发现一个左括号则curly加1，发现一个)则curly减1，直到curly为0则说明闭合
- lastFilterIndex = 0: 解析游标，每循环过一个字符串游标加1

接着，从开头开始遍历传入exp每一个字符，通过判断每一个字符是否是特殊字符，进而判断出exp字符串中哪些部分是表达式，哪些部分是过滤器id。  

上面的代码看上去有点长，其逻辑非常简单，为了便于阅读，我们提供一个上述代码中所涉及到的`ASCII`码与字符串对应关系，如下：
```javascript
0x22 ----- "
0x27 ----- '
0x28 ----- (
0x29 ----- )
0x2f ----- /
0x5c ----- \
ox5B ----- [
0x5D ----- ]
0x60 ----- `
ox7C ----- |
ox7B ----- {
ox7D ----- }
```
上述大妈的逻辑就是将字符串exp的每一个字符从前往后开始一个一个匹配，匹配出哪些特殊字符，如`'`，`"`，`{`，`}`，`[`，`]`，`(`，`)`，`\`，`|`。  

如果匹配到`"`，`'`，字符，说明当前字符在字符串中，那么知道匹配到下一个同样的字符串才结束，同时，匹配`()`，`{}`，`[]`这些需要两边相等闭合，那么匹配到的`|`才被认为是过滤器中的`|`。  

当匹配到过滤器中的`|`符时，那么`|`符前面的字符串就认为是待处理的表达式，将其存储在`expression`中，后面继续匹配，如果再次匹配到过滤器中的`|`符，并且此时`expression`有值，那么说明后面还有第二个过滤器，那么此时两个`|`符之间的字符串就是第一个过滤器的id，此时调用`pushFilter`函数将第一个过滤器添加进`filters`数组中。举个例子：  

假设有如下过滤器字符串：
```javascript
message | filter1 | filter2(arg)
```

将上面的过滤器字符串都匹配完毕后，会得到如下结果：
```javascript
expression = message
filters = ['filter1', 'filter2(arg)']
```

接下来遍历得到的filters数组，并且将数组的每一个元素及expression传给wrapFilter函数，用来生成最终的_f函数调用字符串，如下：

```javascript
if(filters) {
  for(i = 0; i < filters.length; i++) {
    expression = wrapFilter(expression, filters[i])
  }
}


```